parser grammar DecaParser;

options {
	// Default language but name it anyway
	language = Java;

	// Use a superclass to implement all helper methods, instance variables and overrides of ANTLR
	// default methods, such as error handling.
	superClass = AbstractDecaParser;

	// Use the vocabulary generated by the accompanying lexer. Maven knows how to work out the
	// relationship between the lexer and parser and will build the lexer before the parser. It will
	// also rebuild the parser if the lexer changes.
	tokenVocab = DecaLexer;
}

// which packages should be imported?
@header {
    import fr.ensimag.deca.tree.*;
    import java.io.PrintStream;
    import fr.ensimag.deca.tools.SymbolTable;
    import fr.ensimag.deca.tools.SymbolTable.Symbol;
    import fr.ensimag.deca.context.Type;
}

@members {
    @Override
    protected AbstractProgram parseProgram() {
        return prog().tree;
    }
}

prog
	returns[AbstractProgram tree]:
	list_classes main EOF {
            assert($list_classes.tree != null) : "message1" ;
            assert($main.tree != null) : "message2" ;
            $tree = new Program($list_classes.tree, $main.tree);
            setLocation($tree, $list_classes.start);
        };

main
	returns[AbstractMain tree]:
	/* epsilon */ {
            $tree = new EmptyMain();
        }
	| block {
            assert($block.decls != null) : "message3" ;
            assert($block.insts != null) : "message2" ;
            $tree = new Main($block.decls, $block.insts);
            setLocation($tree, $block.start);
        };

block
	returns[ListDeclVar decls, ListInst insts]:
	OBRACE list_decl list_inst CBRACE {
            assert($list_decl.tree != null) ;
            assert($list_inst.tree != null) ;
            $decls = $list_decl.tree;
            $insts = $list_inst.tree;
            
        };

list_decl
	returns[ListDeclVar tree]
	@init {
            $tree = new ListDeclVar();
        }: decl_var_set[$tree]*;

decl_var_set[ListDeclVar l]:
	type list_decl_var[$l,$type.tree] SEMI;

list_decl_var[ListDeclVar l, AbstractIdentifier t]:
	dv1 = decl_var[$t] {
        $l.add($dv1.tree);
        setLocation($dv1.tree, $dv1.start);
        } (
		COMMA dv2 = decl_var[$t] {
            $l.add($dv2.tree);
            setLocation($dv2.tree, $dv2.start);
        }
	)*;

decl_var[AbstractIdentifier t]
	returns[AbstractDeclVar tree]
	@init {
            AbstractIdentifier i;
            AbstractInitialization init = new NoInitialization();
        }:
	i = ident {
        } 
        (
		EQUALS e = expr {
                init = new Initialization($e.tree);
                setLocation(init, $e.start);
        }
	)? {
                $tree = new DeclVar($t, $i.tree, init) ; //DeclVar(AbstractIdentifier type, AbstractIdentifier varName, AbstractInitialization initialization)
                setLocation($i.tree, $i.start);
                setLocation($tree, $i.start);
        };

list_inst
	returns[ListInst tree]
	@init {
    $tree = new ListInst() ;
}: (
		inst {
        $tree.add($inst.tree) ;
        // setLocation($tree, $inst.start);
        }
	)*;

inst
	returns[AbstractInst tree]:
	e1 = expr SEMI {
            assert($e1.tree != null)  ;
            $tree = $e1.tree ;
            //setLocation($tree, $e1.start);
        }
	| SEMI { 
                $tree = new NoOperation();
                setLocation($tree, $SEMI);
        }
	| PRINT OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Print( false , $list_expr.tree ) ;
            setLocation($tree, $PRINT);
        }
	| PRINTLN OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null) : "message8" ;
            $tree = new Println( false , $list_expr.tree ) ;
            setLocation($tree, $PRINTLN);
        }
	| PRINTX OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Print( true , $list_expr.tree ) ;
            setLocation($tree, $PRINTX);
        }
	| PRINTLNX OPARENT list_expr CPARENT SEMI {
            assert($list_expr.tree != null);
            $tree = new Println( true , $list_expr.tree ) ;
            setLocation($tree, $PRINTLNX);
        }
	| if_then_else {
            assert($if_then_else.tree != null);
            $tree = $if_then_else.tree; 
            setLocation($tree, $if_then_else.start);
        }
	| WHILE OPARENT condition = expr CPARENT OBRACE body = list_inst CBRACE {
            assert($condition.tree != null);
            assert($body.tree != null);
            $tree = new While($condition.tree, $body.tree);
            setLocation($tree, $WHILE);
            
        }
	| RETURN expr SEMI {
            assert($expr.tree != null);
            $tree = new Return($expr.tree); 
            setLocation($tree, $RETURN);
        };

if_then_else
	returns[IfThenElse tree]
//IfThenElse(AbstractExpr condition, ListInst thenBranch, ListInst elseBranch)
	@init {
    ListInst list_then_suiv = new ListInst();
    ListInst ancien = list_then_suiv;
    }:
	if1 = IF OPARENT condition = expr CPARENT OBRACE li_if = list_inst CBRACE {  
            $tree = new IfThenElse($condition.tree, $li_if.tree, list_then_suiv); 
            setLocation($tree, $if1);  
        } (
		ELSE elsif = IF OPARENT elsif_cond = expr CPARENT OBRACE elsif_li = list_inst CBRACE {
            ListInst courrant = new ListInst();
            IfThenElse newInst = new IfThenElse( $elsif_cond.tree, $elsif_li.tree, courrant);
            setLocation(newInst, $elsif);
            
            ancien.add(newInst);
            ancien = courrant; 

            $tree = new IfThenElse( $condition.tree, $li_if.tree, list_then_suiv);
            setLocation($tree, $ELSE);
            
        }
	)* (
		ELSE OBRACE li_else = list_inst CBRACE {
                
            if ( list_then_suiv.size() == 0){
                    $tree = new IfThenElse($condition.tree, $li_if.tree, $li_else.tree);
            }
            else{
                 ancien.add($li_else.tree);
            }
        setLocation($tree, $ELSE);          
        }
	)?;

list_expr
	returns[ListExpr tree]
	@init {
    $tree = new ListExpr() ;    
        }: (
		e1 = expr {
        $tree.add($e1.tree);
        } (
			COMMA e2 = expr {
           $tree.add($e2.tree);
        }
		)*
	)?;

expr
	returns[AbstractExpr tree]:
	e = assign_expr {
            assert($assign_expr.tree != null) : "message5" ;
            $tree = $assign_expr.tree ;
            //setLocation($tree, $e.start);
        };

assign_expr
	returns[AbstractExpr tree]:
	e = or_expr (
		/* condition: expression e must be a "LVALUE" */ {
            if (! ($e.tree instanceof AbstractLValue)) {
                throw new InvalidLValue(this, $ctx);
            }
        } EQUALS e2 = assign_expr {
            assert($e.tree != null);
            assert($e2.tree != null);
            $tree = new Assign( (AbstractLValue) $e.tree, $e2.tree ) ;
            setLocation($tree, $EQUALS);
        }
		| /* epsilon */ {
            assert($e.tree != null) ;
            $tree = $e.tree ;
            //setLocation($tree, $e.start);
        });

or_expr
	returns[AbstractExpr tree]:
	e = and_expr {
            assert($e.tree != null);
            $tree = $e.tree ;
            //setLocation($tree, $e.start);
        }
	| e1 = or_expr OR e2 = and_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Or( $e1.tree, $e2.tree ) ;
            setLocation($tree, $OR);
       };

and_expr
	returns[AbstractExpr tree]:
	e = eq_neq_expr {
            assert($e.tree != null);
            $tree = $e.tree ;
            //setLocation($tree, $e.start);
        }
	| e1 = and_expr AND e2 = eq_neq_expr {
            assert($e1.tree != null);                         
            assert($e2.tree != null);
            $tree = new And ( $e1.tree, $e2.tree ) ;
            setLocation($tree, $AND);
            //setLocation($tree, $e2.start);
        };

eq_neq_expr
	returns[AbstractExpr tree]:
	e = inequality_expr {
            assert($e.tree != null);
            $tree = $e.tree ;
            //setLocation($tree, $e.start);
        }
	| e1 = eq_neq_expr EQEQ e2 = inequality_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Equals($e1.tree , $e2.tree ) ;
            setLocation($tree, $EQEQ);
            //setLocation($tree, $e2.start);
        }
	| e1 = eq_neq_expr NEQ e2 = inequality_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new NotEquals($e1.tree , $e2.tree ) ;
            setLocation($tree, $NEQ);
            //setLocation($tree, $e2.start);
        };

inequality_expr
	returns[AbstractExpr tree]:
	e = sum_expr {
            assert($e.tree != null);
            $tree = $e.tree ;
            //setLocation($tree, $e.start);
        }
	| e1 = inequality_expr LEQ e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new LowerOrEqual($e1.tree, $e2.tree) ;
            setLocation($tree, $LEQ);
        }
	| e1 = inequality_expr GEQ e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new GreaterOrEqual($e1.tree, $e2.tree) ;
            setLocation($tree, $GEQ);
        }
	| e1 = inequality_expr GT e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Greater($e1.tree, $e2.tree) ;
            setLocation($tree, $GT);
        }
	| e1 = inequality_expr LT e2 = sum_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Lower($e1.tree, $e2.tree) ;
            setLocation($tree, $LT);
        }
	/*
	 | e1=inequality_expr INSTANCEOF type { assert($e1.tree != null); assert($type.tree != null); }
	 A Faire avec class
	 */;

sum_expr
	returns[AbstractExpr tree]:
	e = mult_expr {
            assert($e.tree != null);
            $tree = $e.tree ;
        }
	| e1 = sum_expr PLUS e2 = mult_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Plus ($e1.tree , $e2.tree) ;
            setLocation($tree, $PLUS);
        }
	| e1 = sum_expr MINUS e2 = mult_expr {
            assert($e1.tree != null);
            assert($e2.tree != null);
            $tree = new Minus ($e1.tree , $e2.tree) ;
            setLocation($tree, $MINUS);
        };

        

mult_expr
	returns[AbstractExpr tree]:
	e = unary_expr {
            assert($e.tree != null);
            $tree = $e.tree ;
            //setLocation($tree, $e.start);
        }
	| e1 = mult_expr TIMES e2 = unary_expr {
            assert($e1.tree != null);                                         
            assert($e2.tree != null);
            $tree = new Multiply ($e1.tree , $e2.tree) ;
            setLocation($tree, $TIMES);
            //setLocation($tree, $e1.start);
            ////setLocation($tree, $e2.start);
        }
	| e1 = mult_expr SLASH e2 = unary_expr {
            assert($e1.tree != null);                                         
            assert($e2.tree != null);
            $tree = new Divide ($e1.tree , $e2.tree) ;
            setLocation($tree, $SLASH);
        }
	| e1 = mult_expr PERCENT e2 = unary_expr {
            assert($e1.tree != null);                                                                          
            assert($e2.tree != null);
            $tree = new Modulo ($e1.tree , $e2.tree) ;
            setLocation($tree, $PERCENT);
            //setLocation($tree, $e2.start);
        };

unary_expr
	returns[AbstractExpr tree]:
	op = MINUS e = unary_expr {
            assert($e.tree != null);
            $tree = new UnaryMinus($e.tree);
            setLocation($tree, $op);

        }
	| op = EXCLAM e = unary_expr {
            assert($e.tree != null);
            $tree = new Not($e.tree);
            setLocation($tree, $op);
        }
        | op = LENGTH OPARENT primary_expr CPARENT {
                assert($primary_expr.tree != null);
                $tree = new Length($primary_expr.tree);
                setLocation($tree, $op);
        }
	| select_expr {
            assert($select_expr.tree != null);
            $tree = $select_expr.tree;
            //setLocation($tree, $select_expr.start);
        };

select_expr
	returns[AbstractExpr tree]:
	e = primary_expr {
            assert($e.tree != null);
            $tree = $e.tree;
            //setLocation($tree, $e.start);
        }
        | e1 = select_expr DOT i = ident {
            assert($e1.tree != null);
            assert($i.tree != null);
            //setLocation($tree, $i.start);

        } (
		o = OPARENT args = list_expr CPARENT {
            // we matched "e1.i(args)"
            $tree  =  new MethodCall($e1.tree, $i.tree, $args.tree);
            setLocation($tree, $e1.start);
            assert($args.tree != null);
        }
		| /* epsilon */ {
            // we matched "e.i"
            $tree = new MethodCall($e1.tree, $i.tree);
            setLocation($tree, $e1.start);
        }
	);

primary_expr
	returns[AbstractExpr tree]:
	ident {
            assert($ident.tree != null);
            $tree = $ident.tree;
            //setLocation($tree, $ident.start);

        }
	| m = ident OPARENT args = list_expr CPARENT {
            assert($args.tree != null);
            assert($m.tree != null);
            $tree  =  new MethodCall($m.tree, $args.tree);
            setLocation($tree, $m.start);
        }
        | OBRACE args = list_expr CBRACE {
                assert($args.tree != null);
                $tree = new Table($args.tree);
                setLocation($tree, $OBRACE);
        }
        | NEW type OBRACKET expr CBRACKET {
                assert($type.tree != null);
                assert($expr.tree != null);
                $tree = new Table($type.tree, $expr.tree);
                setLocation($tree, $NEW);

        }
	| OPARENT expr CPARENT {
            assert($expr.tree != null);
            $tree = $expr.tree;
            //setLocation($tree, $expr.start);
        }
	| READINT OPARENT CPARENT {
            $tree = new ReadInt();
            setLocation($tree, $READINT);
        }
	| READFLOAT OPARENT CPARENT {
        $tree = new ReadFloat();
        setLocation($tree, $READFLOAT);
        }
	| NEW ident OPARENT CPARENT {
            assert($ident.tree != null);
            $tree = new New($ident.tree);
            setLocation($tree, $NEW);
        }
	| cast = OPARENT type CPARENT OPARENT expr CPARENT {
            assert($type.tree != null);
            assert($expr.tree != null);
            $tree = new Cast($type.tree, $expr.tree);
            setLocation($tree, $cast);
        }
	| literal {
            assert($literal.tree != null);
            $tree = $literal.tree;
            setLocation($tree, $literal.start);
        }
        | ident OBRACKET e = expr CBRACKET{
                SymbolTable table = getDecacCompiler().getsymbolTable();
                //Symbol symbolIdent = table.create($ident.text);
                Symbol symbolElem = table.create($ident.text + $OBRACKET.text + $e.text + $CBRACKET.text);
                $tree = new ElementTable($ident.tree, symbolElem, $e.tree);
                setLocation($tree, $ident.start);
        }
        | ident OBRACKET e1 = expr CBRACKET OBRACKET e2 = expr CBRACKET {
                SymbolTable table = getDecacCompiler().getsymbolTable();
                Symbol symbol1 = table.create($ident.text + $OBRACKET.text + $e1.text + $CBRACKET.text);
                Symbol symbolElem = table.create($ident.text + $OBRACKET.text + $e1.text + $CBRACKET.text + $OBRACKET.text + $e2.text + $CBRACKET.text);
                AbstractIdentifier ident1 = new ElementTable($ident.tree, symbol1, $e1.tree);
                $tree = new ElementTable(ident1, symbolElem, $e2.tree);
                setLocation($tree, $ident.start);
        }
        ;

type
	returns[AbstractIdentifier tree]:
	ident {
            assert($ident.tree != null)  ;
            $tree = $ident.tree ;   
        };

literal
	returns[AbstractExpr tree]:
	INT {
        try{
        $tree = new IntLiteral(Integer.parseInt($INT.text));
        } catch(NumberFormatException e) { throw new DecaRecognitionException(this, $ctx, "L'entier est trop grand"); }
        }
	| fd = FLOAT {
                try{
                        if (Float.parseFloat($fd.text) >= Math.pow(2,-149) || Float.parseFloat($fd.text) == 0.0) {
                                $tree = new FloatLiteral(Float.parseFloat($fd.text));
                        } else { throw new DecaRecognitionException(this, $ctx, "Le flottant est trop petit" ); }
                }
                catch(IllegalArgumentException e){
                        throw new DecaRecognitionException(this, $ctx, "Le flottant est trop grand" );
                }
        }
	| STRING {
        String str = $STRING.text;
        String new_str = str.substring(1, str.length()-1);
        $tree = new StringLiteral(new_str);
        }
	| TRUE {
        $tree = new BooleanLiteral(true);
        }
	| FALSE {
        $tree = new BooleanLiteral(false);
        }
	| THIS { 
        $tree = new This();   
        }
	| NULL {
        };

ident
	returns[AbstractIdentifier tree]:
	IDENT {
        SymbolTable table = getDecacCompiler().getsymbolTable();
        Symbol symbol = table.create($IDENT.text);
        $tree = new Identifier(symbol);
        setLocation($tree, $IDENT);    
        }
        // | IDENT OBRACKET expr CBRACKET{
        // SymbolTable table = getDecacCompiler().getsymbolTable();
        // Symbol symbol = table.create($IDENT.text + $OBRACKET.text + $expr.text + $CBRACKET.text);
        // $tree = new Identifier(symbol);
        // setLocation($tree, $IDENT);
        // }        
        ;

/****     Class related rules     ****/

list_classes
	returns[ListDeclClass tree]
	@init {
         $tree = new ListDeclClass();
        }: class_decl[$tree]*;

class_decl[ListDeclClass l]
        @init {
            AbstractIdentifier name;
            //AbstractIdentifier superclass = new Identifier(getDecacCompiler().getsymbolTable().create("Object"));
        }:
	CLASS name = ident superclass = class_extension OBRACE class_body CBRACE {
                DeclClass nouvClass = new DeclClass($name.tree, $superclass.tree, $class_body.listMethod, $class_body.listField);
                setLocation(nouvClass, $CLASS);
                l.add(nouvClass);
                
        };

class_extension
	returns[AbstractIdentifier tree]:
	EXTENDS ident {
                assert($ident.tree != null);
                $tree= $ident.tree;
                setLocation($tree, $EXTENDS); 
        }
	| /* epsilon */ {
                SymbolTable table = new SymbolTable();
                Symbol symbol = table.create("Object");
                Identifier superclass = new Identifier(symbol);
                superclass.setDefinition(getDecacCompiler().getenvType().get(symbol));
                $tree = superclass;
        };

class_body returns[ListDeclMethod listMethod, ListDeclField listField]
@init {
        $listField = new ListDeclField();
        $listMethod = new ListDeclMethod();
}: (
		m = decl_method {
                        $listMethod.add($m.tree);
        }
		| decl_field_set[$listField]{
                }
	)*{
        };

decl_field_set [ListDeclField l]: v = visibility t = type list_decl_field[$l,$type.tree,$v.v] SEMI;

visibility returns[Visibility v]:
	/* epsilon */ {
                $v = Visibility.PUBLIC;
        }
	| PROTECTED {
                $v = Visibility.PROTECTED;
        };

list_decl_field [ListDeclField l, AbstractIdentifier t, Visibility v]: 
        dv1 = decl_field[$t, $v]{
                l.add($dv1.tree);
                setLocation($dv1.tree, $dv1.start);
         } (
                 COMMA dv2 = decl_field[$t, $v]{
                l.add($dv2.tree);
                setLocation($dv2.tree, $dv2.start);
         }
         )*;

decl_field[AbstractIdentifier t, Visibility v]
        returns [AbstractDeclField tree]
        @init{
                AbstractInitialization init = new NoInitialization();
        }:
	i = ident {
        } (
		EQUALS e = expr {
                init = new Initialization($e.tree);
                setLocation(init, $e.start);
        }
	)? {
                $tree = new DeclField($t, $ident.tree, $v ,init) ;
                setLocation($ident.tree, $ident.start);
                setLocation($tree, $ident.start);
        };

decl_method
        returns[AbstractMethod tree]
	@init {
}:
	type ident OPARENT params = list_params CPARENT (
		block {
                        assert($block.decls != null) : "message3" ;
                        assert($block.insts != null) : "message2" ;
                        $tree = new Method($type.tree, $ident.tree, $block.decls, $block.insts, $list_params.tree);
                        setLocation($tree, $type.start);
        }
		| ASM OPARENT code = multi_line_string CPARENT SEMI {
                        $tree = new AssemblyMethod($multi_line_string.text, $type.tree, $ident.tree, $list_params.tree);
                        setLocation($tree, $ASM);
        }
	) {
        };

list_params
        returns[ListParams tree]
        @init{
                $tree = new ListParams();
        }: (
		p1 = param {
                        $tree.add($p1.tree);
        } (
			COMMA p2 = param {
                        $tree.add($p2.tree);
        }
		)*
	)?;

multi_line_string
	returns[String text, Location location]:
	s = STRING {
            $text = $s.text;
            $location = tokenLocation($s);
        }
	| s = MULTI_LINE_STRING {
            $text = $s.text;
            $location = tokenLocation($s);
        };

param
        returns[AbstractParams tree]:
	type ident {
                $tree = new Params($type.tree, $ident.tree);
                setLocation($tree, $type.start);
        };